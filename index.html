<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gentleman AI Generator</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        darkMode: 'class',
        theme: {
          extend: {
            colors: {
              primary: 'var(--primary)',
              secondary: 'var(--secondary)',
              bg: 'var(--bg)',
              card: 'var(--card)',
              text: 'var(--text)',
              'sub-text': 'var(--sub-text)',
              border: 'var(--border)',
            },
            animation: {
              'fade-in': 'fadeIn 0.5s ease-out',
              'pulse-fast': 'pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite',
              'bounce-small': 'bounceSmall 0.3s',
              'shake': 'shake 0.4s ease-in-out',
            },
            keyframes: {
              fadeIn: {
                '0%': { opacity: '0', transform: 'translateY(10px)' },
                '100%': { opacity: '1', transform: 'translateY(0)' },
              },
              bounceSmall: {
                '0%, 100%': { transform: 'scale(1)' },
                '50%': { transform: 'scale(0.95)' },
              },
              shake: {
                '0%, 100%': { transform: 'translateX(0)' },
                '20%': { transform: 'translateX(-5px)' },
                '40%': { transform: 'translateX(5px)' },
                '60%': { transform: 'translateX(-3px)' },
                '80%': { transform: 'translateX(3px)' },
              }
            }
          }
        }
      }
    </script>
    <style>
      :root {
        --primary: #007AFF;
        --secondary: #5AC8FA;
        --bg: #F2F2F7;
        --card: #FFFFFF;
        --text: #000000;
        --sub-text: #8E8E93;
        --border: rgba(0, 0, 0, 0.08);
      }

      html.dark-mode {
        --bg: #000000;
        --card: #1C1C1E;
        --text: #FFFFFF;
        --sub-text: #98989D;
        --border: rgba(255, 255, 255, 0.1);
        --primary: #0A84FF;
      }

      /* Themes */
      html.theme-pink { --primary: #FB7DA8; --secondary: #FFB7CE; }
      html.dark-mode.theme-pink { --primary: #FF85B3; }
      
      html.theme-teal { --primary: #008ba3; --secondary: #5AC8FA; }
      html.theme-silver { --primary: #636366; --secondary: #AEAEB2; --bg: #F2F2F7; }
      html.dark-mode.theme-silver { --bg: #000000; --primary: #98989D; }
      
      html.theme-gold { --primary: #F59E0B; --secondary: #FFCC00; --bg: #FFF9E6; }
      html.dark-mode.theme-gold { --bg: #000000; --primary: #FFD60A; }
      
      html.theme-orange { --primary: #F37021; --secondary: #FF9F55; --bg: #FFF5EE; }
      html.dark-mode.theme-orange { --bg: #000000; --primary: #FF8C42; }

      html.theme-purple { --primary: #AF52DE; --secondary: #BF5AF2; }
      html.theme-wine { --primary: #A00030; --secondary: #FF3B30; }
      html.theme-colorful { --primary: #FF2D55; --secondary: #AF52DE; }

      html.theme-mono { --primary: #333; --secondary: #666; --bg: #F2F2F7; --card: #FFF; }
      html.dark-mode.theme-mono { --bg: #000; --card: #1C1C1E; --primary: #8E8E93; }
      
      html.theme-twitter { --bg: #FFFFFF; --card: #FFFFFF; --primary: #1D9BF0; --text: #0F1419; }
      html.dark-mode.theme-twitter { --bg: #000000; --card: #000000; --primary: #1D9BF0; --text: #E7E9EA; }

      html.theme-fanbox { --primary: #F5C500; --secondary: #FFEA66; --bg: #F8F8F8; }
      html.dark-mode.theme-fanbox { --bg: #000000; --primary: #FFD800; }
      
      html.theme-youtube { --primary: #FF0000; --secondary: #FF4444; }
      html.theme-tech { --primary: #0070F3; --secondary: #50E3C2; --bg: #F0F5FF; }
      html.dark-mode.theme-tech { --primary: #00F0FF; --bg: #050A14; --card: #0A1428; --text: #E0F0FF; }
      
      html.theme-plurk { --primary: #CF473E; --secondary: #FF8077; --bg: #FDF6E3; }
      html.dark-mode.theme-plurk { --bg: #1A1A1A; --primary: #FF574D; }
      
      html.theme-melon { --primary: #66CC33; --secondary: #88DD55; }

      body {
        -webkit-tap-highlight-color: transparent;
        font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      }
      ::-webkit-scrollbar { width: 0px; background: transparent; }
    </style>

    <!-- Dependencies -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>

    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "@google/genai": "https://esm.sh/@google/genai@latest",
        "lucide-react": "https://esm.sh/lucide-react@0.263.1"
      }
    }
    </script>
</head>
<body class="bg-bg text-text transition-colors duration-300">
    <div id="root"></div>

    <script type="text/babel" data-type="module" data-presets="typescript,react">
      import React, { useState, useEffect, useCallback, useRef } from 'react';
      import { createRoot } from 'react-dom/client';
      import { GoogleGenAI, Type } from '@google/genai';
      import { 
        RefreshCw, Dices, Copy, Volume2, Star, Search, History, Trophy, Settings, 
        Wand2, MessageCircle, ChevronDown, ChevronUp, Plus, Heart, X, Trash2, 
        RotateCcw, Download, Check, Upload, Type as TypeIcon, BookOpen, Palette 
      } from 'lucide-react';

      // ==========================================
      // ğŸ”‘ è«‹åœ¨é€™è£¡è¨­å®šæ‚¨çš„ API KEY
      // ==========================================
      const API_KEY = "åœ¨æ­¤å¡«å…¥æ‚¨çš„_GEMINI_API_KEY"; 
      // ==========================================

      // --- TYPES ---
      interface Phrase { jp: string; cn: string; }
      interface SubCategory { label: string; phrases: Phrase[]; }
      interface MainCategory { label: string; subs: Record<string, SubCategory>; }
      interface Database { [key: string]: MainCategory; }
      interface GeneratedResult { base: Phrase; emoji: string; id: string; }
      enum AppStatusType { IDLE = 'IDLE', SELECTED = 'SELECTED', GEN_REPLY = 'GEN_REPLY', GEN_KEYWORD = 'GEN_KEYWORD', AI_REWRITING = 'AI_REWRITING' }
      interface AppStatus { type: AppStatusType; text: string; }
      enum EmojiStyle { EXCLAMATION = 0, KAOMOJI = 1, CUSTOM = 2, FACES = 3 }
      interface AchievementDef { id: string; icon: string; title: string; desc: string; }
      interface UserAchievement { unlocked: boolean; date: number; }
      interface SavedCategory { main: string; sub: string; label: string; }
      interface AppSettings {
        fontSize: number; resultCount: number; showCN: boolean; showSpeak: boolean; customMin: number; customMax: number;
        voiceRate: number; voicePitch: number; userXP: number; userLevel: number; userTheme: string; darkMode: boolean;
        hideFun: boolean; totalCopies: number;
        activeFaces: string[]; activeDecor: string[]; disabledFaces: string[]; disabledDecor: string[];
      }
      type ModalType = 'settings' | 'history' | 'achievements' | 'tutorial' | 'welcome' | 'xp' | null;

      // --- CONSTANTS ---
      const SHEET_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSM6yn6wGB_TcdLtSDqQMiaDL3WICybpnSqDXqMn8sQ1XFLjiqdqqQib2bO1x7nAHrWYVK7VSrDU2io/pub?output=csv';
      const MODEL_NAME = 'gemini-2.5-flash';
      
      const LEVEL_TITLES: Record<number, string> = { 
        1: "è¦‹ç¿’ç´³å£«", 10: "è®Šæ…‹é å‚™è»", 20: "è³¢è€…æ¨¡å¼", 30: "è³‡æ·±è€å¸æ©Ÿ", 40: "ç´³å£«é‘‘è³å®¶", 50: "ç¢©æœåƒ…å­˜çš„ç´³å£«", 
        60: "è®Šæ…‹çš„æ¥µè‡´", 70: "ç´³å£«å¤§å¸«", 80: "è®Šæ…‹å®—å¸«", 90: "ç´³å£«ä¹‹ç¥", 100: "å‚³èªªä¸­çš„è®Šæ…‹", 
        110: "è–„æœ¬çµäºº", 120: "è–å…‰ç ´å£è€…", 130: "çµ•å°é ˜åŸŸè§€æ¸¬å“¡", 140: "æƒ¡å¢®é‘‘è³å®¶", 150: "è§¸æ‰‹æ“æ§å¸«", 
        160: "ç•°ç¨®å§¦å¯©æŸ¥å®˜", 170: "æ™‚é–“åœæ­¢ä½¿ç”¨è€…", 180: "å‚¬çœ æ´—è…¦å¤§å¸«", 190: "æ­¥å…µåœ˜ç¸½å¸ä»¤", 200: "è®Šæ…‹ç´³å£«ç‹" 
      };

      const UNLOCKS: Record<number, string> = { 
          10: "ğŸŒ¸ æˆ€æ„›ç²‰ä¸»é¡Œ", 20: "ğŸ§˜ è³¢è€…é»‘ç™½ä¸»é¡Œ", 30: "ğŸŒ¿ æ¸…æ–°ç¶ ä¸»é¡Œ", 40: "ğŸ· é…’ç´…è‰²ä¸»é¡Œ", 
          50: "ğŸ¥ˆ å†·å†½éŠ€ä¸»é¡Œ", 60: "ğŸ”® å¤¢å¹»ç´«ä¸»é¡Œ", 70: "ğŸ‘‘ å¸ç‹é‡‘ä¸»é¡Œ", 80: "ğŸŒˆ è‰²å½©ç¹½ç´›ä¸»é¡Œ", 
          90: "âœ–ï¸ X é…è‰²ä¸»é¡Œ", 100: "ğŸŠ æ„›é¦¬ä»•æ©˜ä¸»é¡Œ", 110: "ğŸ“¦ Fanbox ä¸»é¡Œ", 120: "â–¶ï¸ Youtube ä¸»é¡Œ", 
          130: "ğŸ¤– ç§‘æŠ€è—ä¸»é¡Œ", 140: "ğŸ¦´ å™—æµªä¸»é¡Œ", 150: "ğŸˆ Melon ä¸»é¡Œ" 
      };

      const ACHIEVEMENTS_DATA: Record<string, AchievementDef> = {
          "first_copy": { id: "first_copy", icon: "ğŸŒ±", title: "åˆå‡ºèŒ…å»¬", desc: "ç¬¬ä¸€æ¬¡è¤‡è£½ä»»ä½•å¥å­" },
          "first_fav": { id: "first_fav", icon: "â­", title: "å¿ƒå‹•æ™‚åˆ»", desc: "ç¬¬ä¸€æ¬¡å°‡å¥å­åŠ å…¥ã€Œæˆ‘çš„æœ€æ„›ã€" },
          "first_search": { id: "first_search", icon: "ğŸ”", title: "å°‹å¯¶çµäºº", desc: "ä½¿ç”¨é 1 æ¬¡ã€Œæœå°‹ã€åŠŸèƒ½" },
          "read_tutorial": { id: "read_tutorial", icon: "ğŸ“–", title: "å¥½å­¸ç”Ÿ", desc: "å®Œæ•´æ‰“é–‹ä¸¦é–±è®€éã€Œä½¿ç”¨æ•™å­¸ã€" },
          "download_card": { id: "download_card", icon: "ğŸ“¸", title: "æ°¸æ†çš„ç¬é–“", desc: "æˆåŠŸä¸‹è¼‰ä¸€æ¬¡ã€Œä»Šæ—¥é‹å‹¢ã€åœ–ç‰‡" },
          "n1_japanese": { id: "n1_japanese", icon: "ğŸ‡¯ğŸ‡µ", title: "æ—¥æ–‡N1", desc: "åœ¨è¨­å®šä¸­é—œé–‰ã€Œé¡¯ç¤ºä¸­æ–‡ç¿»è­¯ã€" },
          "copy_50": { id: "copy_50", icon: "ğŸ—£ï¸", title: "å£è‹¥æ‡¸æ²³", desc: "ç´¯è¨ˆè¤‡è£½æ¬¡æ•¸é”åˆ° 50 æ¬¡" },
          "copy_500": { id: "copy_500", icon: "ğŸ’˜", title: "åƒè¨€è¬èª", desc: "ç´¯è¨ˆè¤‡è£½æ¬¡æ•¸é”åˆ° 500 æ¬¡" },
          "combo_master": { id: "combo_master", icon: "âš¡", title: "é€£æ“Šå¤§å¸«", desc: "åœ¨ 10 ç§’å…§é€£çºŒè¤‡è£½ 5 æ¬¡" },
          "fav_full": { id: "fav_full", icon: "ğŸ’—", title: "åšæ„›ä¸»ç¾©è€…", desc: "æˆ‘çš„æœ€æ„›å­˜æ»¿ 24 å€‹å¥å­" },
          "fav_del": { id: "fav_del", icon: "ğŸ’”", title: "æ–·æ¨é›¢", desc: "å¾æˆ‘çš„æœ€æ„›ä¸­åˆªé™¤ä¸€å€‹å¥å­" },
          "regen_20": { id: "regen_20", icon: "ğŸ”„", title: "æ›å¸–å…„å¼Ÿ", desc: "é€£çºŒé»æ“Šã€Œæ›ä¸€æ‰¹ã€æŒ‰éˆ• 20 æ¬¡" },
          "five_star_general": { id: "five_star_general", icon: "ğŸ–ï¸", title: "äº”æ˜Ÿä¸Šå°‡", desc: "åœ¨ä»Šæ—¥é‹å‹¢ä¸­æŠ½åˆ°äº”æ˜Ÿé‡‘æ¡†" },
          "voice_lover": { id: "voice_lover", icon: "ğŸ”Š", title: "è²ä¹‹å½¢", desc: "é»æ“Š 10 æ¬¡èªéŸ³æ’­æ”¾æŒ‰éˆ•" },
          "rap_god": { id: "rap_god", icon: "ğŸ¤", title: "å¿«å˜´é¥’èˆŒ", desc: "å°‡èªéŸ³èªé€Ÿèª¿åˆ°æœ€å¿« (1.5) ä¸¦æŒ‰ä¸‹è©¦è½" },
          "custom_emoji": { id: "custom_emoji", icon: "ğŸ™‚", title: "è¡¨æƒ…éŠé‡‘è¡“å¸«", desc: "åœ¨è¨­å®šä¸­æ–°å¢ä¸€å€‹ã€Œè‡ªè¨‚è¡¨æƒ…ç¬¦è™Ÿã€" },
          "erotic_fan": { id: "erotic_fan", icon: "ğŸ”", title: "èª å¯¦çš„ç´³å£«", desc: "é€£çºŒç”Ÿæˆã€ŒğŸ” ç´³å£«è®šç¾ã€åˆ†é¡ 10 æ¬¡" },
          "pure_love": { id: "pure_love", icon: "ğŸ¥°", title: "ç´”æ„›æˆ°å£«", desc: "é€£çºŒç”Ÿæˆã€ŒğŸ¥° å–®ç´”å¯æ„›ã€åˆ†é¡ 10 æ¬¡" },
          "kaomoji_fan": { id: "kaomoji_fan", icon: "(=^ãƒ»^=)", title: "é¡æ–‡å­—æ§", desc: "å°‡è¡¨æƒ…è¨­å®šåˆ‡æ›ç‚ºã€Œé¡æ–‡å­—ã€ä¸¦ç”Ÿæˆ" },
          "color_master": { id: "color_master", icon: "ğŸŒˆ", title: "è‰²å½©å¤§å¸«", desc: "æ›´æ›é 3 ç¨®ä¸åŒçš„ä»‹é¢ä¸»é¡Œ" },
          "ai_awakening": { id: "ai_awakening", icon: "ğŸ¤–", title: "æ©Ÿæ¢°é£›æ˜‡", desc: "æˆåŠŸä½¿ç”¨ AI åŠŸèƒ½é€²è¡Œæ“´å¯«" },
          "level_50": { id: "level_50", icon: "ğŸ¥ˆ", title: "åŠç™¾ç´³å£«", desc: "ç­‰ç´šé”åˆ° LV.50" },
          "level_100": { id: "level_100", icon: "ğŸ‘‘", title: "ç™¾ç´šæˆç¥", desc: "ç­‰ç´šé”åˆ° LV.100" },
          "all_complete": { id: "all_complete", icon: "ğŸ†", title: "å¤§æ»¿è²«", desc: "è§£é–æ‰€æœ‰å…¶ä»–æˆå°±" }
      };

      const DEFAULT_FACES = ["ğŸ˜", "ğŸ¥°", "ğŸ˜˜", "ğŸ˜š", "ğŸ˜‹", "ğŸ¥µ", "ğŸ˜³", "ğŸ¥º", "ğŸ˜­", "ğŸ˜¤", "ğŸ™", "ğŸ¤¤", "ğŸ˜µâ€ğŸ’«", "ğŸ« "];
      const DEFAULT_DECOR = ["â¤ï¸", "ğŸ§¡", "ğŸ’›", "ğŸ’™", "ğŸ’œ", "âœ¨", "ğŸŒŸ", "ğŸ’«", "ğŸ’¥", "ğŸ”¥", "ğŸ’¦", "ğŸ’–", "ğŸ’˜", "ğŸ’"];
      const PUNCTUATIONS = ["â€¦", "â€¦ï¼", "â€¦ï¼ï¼", "ï¼", "ï¼ï¼", "ï¼ï¼ï¼"];
      const KAOMOJI = ["(â‰§âˆ‡â‰¦)", "(*Â°âˆ€Â°)=3", "(Â´;;Ï‰;;`)", "ğŸ™âœ¨", "(//âˆ‡//)"];

      const DEFAULT_SETTINGS: AppSettings = {
        fontSize: 1, resultCount: 6, showCN: true, showSpeak: true, customMin: 3, customMax: 5,
        voiceRate: 1.1, voicePitch: 1.0, userXP: 0, userLevel: 1, userTheme: 'default',
        darkMode: false, hideFun: false, totalCopies: 0,
        activeFaces: [...DEFAULT_FACES], activeDecor: [...DEFAULT_DECOR], disabledFaces: [], disabledDecor: []
      };

      // --- SERVICES ---

      // Data Service
      const stripEmojis = (str) => {
          if (!str) return "";
          return str.replace(/[^\u4E00-\u9FFF\u3040-\u309F\u30A0-\u30FF\uFF00-\uFFEF\u0020-\u007E\u00A0-\u00FF\u3000-\u303F]/g, '').replace(/\s+/g, ' ').trim();
      };

      const fetchData = async () => {
          const FALLBACK_DATA = {
             "Reaction": { label: "â« åæ‡‰çŸ­å¥", subs: { "Cute": { label: "ğŸ¥° å–®ç´”å¯æ„›", phrases: [{ jp: "å°Šã„...", cn: "å¤ªå°Šäº†..." }, { jp: "å¥½ã...", cn: "å¥½å–œæ­¡..." }] } } }
          };
          try {
              const response = await fetch(SHEET_CSV_URL);
              if (!response.ok) throw new Error("Network response was not ok");
              const text = await response.text();
              const db = {};
              const rows = text.split(/\r?\n/).slice(1);
              rows.forEach(row => {
                  if (!row.trim()) return;
                  const cols = row.split(','); 
                  if (cols.length < 4) return;
                  const mainKey = cols[0]?.trim().replace(/^"|"$/g, '');
                  const subKey = cols[1]?.trim().replace(/^"|"$/g, '');
                  const jpText = stripEmojis(cols[2]?.trim().replace(/^"|"$/g, ''));
                  const cnText = stripEmojis(cols[3]?.trim().replace(/^"|"$/g, ''));
                  if (!mainKey || !subKey || !jpText) return;
                  if (!db[mainKey]) db[mainKey] = { label: mainKey, subs: {} };
                  if (!db[mainKey].subs[subKey]) db[mainKey].subs[subKey] = { label: subKey, phrases: [] };
                  db[mainKey].subs[subKey].phrases.push({ jp: jpText, cn: cnText });
              });
              return Object.keys(db).length > 0 ? db : FALLBACK_DATA;
          } catch (error) {
              console.warn("Using fallback data due to fetch error:", error);
              return FALLBACK_DATA;
          }
      };

      // Gemini Service
      // Initialize only if API key is present
      const ai = API_KEY ? new GoogleGenAI({ apiKey: API_KEY }) : null;
      
      const phraseSchema = {
        type: Type.ARRAY,
        items: {
          type: Type.OBJECT,
          properties: {
            jp: { type: Type.STRING, description: "The Japanese phrase" },
            cn: { type: Type.STRING, description: "Traditional Chinese translation" }
          },
          required: ["jp", "cn"]
        }
      };

      const generateKeywords = async (keyword, count = 6) => {
        if (!ai) return [{ jp: "API Key Missing", cn: "è«‹è¨­å®š API Key" }];
        try {
          const prompt = `You are a specialized 'Gentleman AI' praise generator. Generate ${count} short, enthusiastic, anime-fan-culture style praise phrases based on the keyword: "${keyword}". Target audience: Otaku, fans praising artists/vtubers. Tone: Enthusiastic, slightly exaggerated, polite but passionate. Output pure JSON.`;
          const response = await ai.models.generateContent({
            model: MODEL_NAME,
            contents: prompt,
            config: { responseMimeType: "application/json", responseSchema: phraseSchema, temperature: 0.8 }
          });
          return JSON.parse(response.text || "[]");
        } catch (error) { console.error(error); return [{ jp: "ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ", cn: "ç”Ÿæˆå¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦" }]; }
      };

      const generateReply = async (context, count = 6) => {
        if (!ai) return [{ jp: "API Key Missing", cn: "è«‹è¨­å®š API Key" }];
        try {
          const prompt = `You are a supportive fan. The user (an artist or creator) said: "${context}". Generate ${count} distinct, warm, and supportive replies in Japanese with Traditional Chinese translations. Tone: Encouraging, gentlemanly, fan-boy/fan-girl style. Output pure JSON.`;
          const response = await ai.models.generateContent({
            model: MODEL_NAME,
            contents: prompt,
            config: { responseMimeType: "application/json", responseSchema: phraseSchema, temperature: 0.7 }
          });
          return JSON.parse(response.text || "[]");
        } catch (error) { console.error(error); return [{ jp: "ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ", cn: "ç”Ÿæˆå¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦" }]; }
      };

      const rewritePhrases = async (phrases, contextLabel) => {
        if (!ai) return phrases;
        try {
          const inputPhrases = phrases.map(p => p.jp).join(", ");
          const prompt = `Rewrite the following Japanese phrases to be more passionate, 'gentlemanly' (in an anime/otaku cultural sense), and varied. Context/Theme: ${contextLabel}. Original phrases: ${inputPhrases}. Return exactly ${phrases.length} rewritten phrases with their Traditional Chinese translations. Output pure JSON.`;
          const response = await ai.models.generateContent({
            model: MODEL_NAME,
            contents: prompt,
            config: { responseMimeType: "application/json", responseSchema: phraseSchema, temperature: 0.85 }
          });
          return JSON.parse(response.text || "[]");
        } catch (error) { console.error(error); return phrases; }
      };

      // --- MODALS ---
      const ModalOverlay = ({ onClose, children }) => (
        <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/60 backdrop-blur-sm animate-fade-in" onClick={onClose}>
          <div className="bg-card dark:bg-card-dark rounded-[32px] w-full max-w-md shadow-2xl flex flex-col max-h-[85vh] overflow-hidden border border-white/10" onClick={e => e.stopPropagation()}>{children}</div>
        </div>
      );
      const ModalHeader = ({ title, onClose }) => (
        <div className="flex justify-between items-center p-5 border-b border-border bg-bg/50 dark:bg-zinc-900/50 backdrop-blur-md shrink-0">
          <h2 className="text-lg font-black tracking-tight">{title}</h2>
          <button onClick={onClose} className="p-2 rounded-full bg-border hover:bg-slate-200 dark:hover:bg-zinc-700 transition-colors active:scale-90"><X size={20} /></button>
        </div>
      );

      // Components Definitions (SettingsModal, HistoryModal, etc.)
      // Merged into specific components for brevity in this single file approach

      // --- MAIN APP COMPONENT ---
      const App = () => {
        const [db, setDb] = useState({});
        const [loading, setLoading] = useState(true);
        const [isDictExpanded, setIsDictExpanded] = useState(false);
        const [currentMain, setCurrentMain] = useState(null);
        const [currentSub, setCurrentSub] = useState(null);
        const [results, setResults] = useState([]);
        const [status, setStatus] = useState({ type: AppStatusType.IDLE, text: 'è«‹é¸æ“‡é è¨­è¾­åº«æˆ–AIç”Ÿæˆ' });
        const [emojiStyle, setEmojiStyle] = useState(EmojiStyle.FACES);
        const [favorites, setFavorites] = useState([]);
        const [savedCategories, setSavedCategories] = useState([]);
        const [historyLog, setHistoryLog] = useState([]);
        const [inputValue, setInputValue] = useState('');
        const [settings, setSettings] = useState(DEFAULT_SETTINGS);
        const [userAchieve, setUserAchieve] = useState({});
        const [activeModal, setActiveModal] = useState('welcome');
        const [welcomeData, setWelcomeData] = useState({ jp: "è¼‰å…¥ä¸­...", icon: "ğŸ", stars: 3 });
        const [shakingBtn, setShakingBtn] = useState(null);

        // Refs
        const regenCountRef = useRef(0);
        const voiceCountRef = useRef(0);
        const copyTimeRef = useRef(0);
        const copyComboRef = useRef(0);
        const eroticStreakRef = useRef(0);
        const cuteStreakRef = useRef(0);
        const themeSetRef = useRef(new Set());
        const aiLastTime = useRef(0);

        const triggerHaptic = (d = 10) => { if (navigator.vibrate) navigator.vibrate(d); };

        const unlockAchievement = (id) => {
          if (settings.hideFun || userAchieve[id]?.unlocked || !ACHIEVEMENTS_DATA[id]) return;
          setUserAchieve(prev => ({ ...prev, [id]: { unlocked: true, date: Date.now() } }));
          triggerHaptic(50);
          addXP(10);
        };

        const addXP = (amount) => {
          if (settings.hideFun) return;
          setSettings(prev => {
            const newXP = prev.userXP + amount;
            let newLevel = Math.floor(newXP / 5) + 1;
            if (newLevel > prev.userLevel) {
                if(newLevel >= 50) unlockAchievement('level_50');
                if(newLevel >= 100) unlockAchievement('level_100');
                triggerHaptic(200);
            }
            return { ...prev, userXP: newXP, userLevel: newLevel };
          });
        };

        useEffect(() => {
          fetchData().then(data => {
            setDb(data);
            setLoading(false);
            const keys = Object.keys(data);
            if (keys.length > 0) {
              const m = data[keys[Math.floor(Math.random() * keys.length)]];
              const sKeys = Object.keys(m.subs);
              const s = m.subs[sKeys[Math.floor(Math.random() * sKeys.length)]];
              const p = s.phrases[Math.floor(Math.random() * s.phrases.length)];
              const stars = Math.random() < 0.2 ? 5 : (Math.floor(Math.random() * 3) + 3);
              const faces = (settings.activeFaces && settings.activeFaces.length > 0) ? settings.activeFaces : DEFAULT_FACES;
              setWelcomeData({ jp: p.jp, icon: faces[Math.floor(Math.random() * faces.length)] || "ğŸ", stars });
              if (stars === 5) setTimeout(() => unlockAchievement('five_star_general'), 1000);
            }
          });
          // Load LocalStorage
          try {
            const s = localStorage.getItem('appSettings'); if(s) setSettings({...DEFAULT_SETTINGS, ...JSON.parse(s)});
            const f = localStorage.getItem('favorites'); if(f) setFavorites(JSON.parse(f));
            const sc = localStorage.getItem('savedCategories'); if(sc) setSavedCategories(JSON.parse(sc));
            const hl = localStorage.getItem('historyLog'); if(hl) setHistoryLog(JSON.parse(hl));
            const ua = localStorage.getItem('userAchieve'); if(ua) setUserAchieve(JSON.parse(ua));
          } catch(e){}

          const handleMsg = (e) => {
              if (e.data.type === 'LOAD_DATA' && e.data.payload) {
                 const p = typeof e.data.payload === 'string' ? JSON.parse(e.data.payload) : e.data.payload;
                 if(p.appSettings) setSettings(pr => ({...pr, ...p.appSettings}));
                 if(p.favorites) setFavorites(p.favorites);
                 if(p.savedSubCategories) setSavedCategories(p.savedSubCategories);
                 if(p.historyLog) setHistoryLog(p.historyLog);
                 if(p.userAchieve) setUserAchieve(p.userAchieve);
              }
          };
          window.addEventListener('message', handleMsg);
          window.parent.postMessage({ type: 'REQUEST_LOAD' }, "*");
          return () => window.removeEventListener('message', handleMsg);
        }, []);

        useEffect(() => {
          localStorage.setItem('appSettings', JSON.stringify(settings));
          localStorage.setItem('favorites', JSON.stringify(favorites));
          localStorage.setItem('savedCategories', JSON.stringify(savedCategories));
          localStorage.setItem('historyLog', JSON.stringify(historyLog));
          localStorage.setItem('userAchieve', JSON.stringify(userAchieve));
          window.parent.postMessage({ type: 'SAVE_DATA', payload: JSON.stringify({ appSettings: settings, favorites, savedSubCategories: savedCategories, historyLog, userAchieve }) }, "*");
        }, [settings, favorites, savedCategories, historyLog, userAchieve]);

        useEffect(() => {
            const root = document.documentElement;
            root.classList.forEach(c => { if (c.startsWith('theme-')) root.classList.remove(c); });
            if (settings.userTheme !== 'default') root.classList.add(`theme-${settings.userTheme}`);
            if (settings.darkMode) { root.classList.add('dark'); root.classList.add('dark-mode'); } 
            else { root.classList.remove('dark'); root.classList.remove('dark-mode'); }
            const bg = getComputedStyle(root).getPropertyValue('--bg').trim();
            window.parent.postMessage({ type: 'CHANGE_BG', color: bg || '#F2F2F7' }, "*");
            themeSetRef.current.add(settings.userTheme);
            if(themeSetRef.current.size >= 3) unlockAchievement('color_master');
        }, [settings.userTheme, settings.darkMode]);

        useEffect(() => {
            if (!settings.showCN) unlockAchievement('n1_japanese');
            if (settings.activeFaces?.length > DEFAULT_FACES.length) unlockAchievement('custom_emoji');
        }, [settings.showCN, settings.activeFaces]);
        
        useEffect(() => {
            if(userAchieve['all_complete']) return;
            const total = Object.keys(ACHIEVEMENTS_DATA).length - 1;
            const unlocked = Object.values(userAchieve).filter(u => {
                const key = Object.keys(userAchieve).find(k => userAchieve[k] === u);
                return u.unlocked && key && ACHIEVEMENTS_DATA[key]?.id !== 'all_complete';
            }).length;
            if(unlocked >= total && total > 0) unlockAchievement('all_complete');
        }, [userAchieve]);

        const generateEmoji = (style) => {
            if (style === EmojiStyle.EXCLAMATION) return PUNCTUATIONS[Math.floor(Math.random() * PUNCTUATIONS.length)];
            if (style === EmojiStyle.KAOMOJI) return " " + KAOMOJI[Math.floor(Math.random() * KAOMOJI.length)];
            const faces = (settings.activeFaces?.length > 0) ? settings.activeFaces : DEFAULT_FACES;
            const decorList = (settings.activeDecor?.length > 0) ? settings.activeDecor : DEFAULT_DECOR;
            const min = style === EmojiStyle.CUSTOM ? (settings.customMin || 1) : 1;
            const max = style === EmojiStyle.CUSTOM ? (settings.customMax || 3) : 3;
            const count = Math.floor(Math.random() * (max - min + 1)) + min;
            const face = faces[Math.floor(Math.random() * faces.length)];
            let decor = "";
            for(let i=0; i<count; i++) decor += decorList[Math.floor(Math.random() * decorList.length)];
            return " " + face + decor; 
        };

        const createResultsFromPhrases = (phrases) => phrases.map((p, idx) => ({ base: p, emoji: generateEmoji(emojiStyle), id: Date.now() + idx + Math.random().toString() }));
        const getRandomPhrases = (phrases, count) => [...phrases].sort(() => 0.5 - Math.random()).slice(0, count);

        const handleSelectSub = (main, sub, fromFeatured=false) => {
            triggerHaptic(10); setCurrentMain(main); setCurrentSub(sub);
            if(fromFeatured) setIsDictExpanded(false);
            if (sub === "ğŸ” ç´³å£«è®šç¾") { eroticStreakRef.current++; if(eroticStreakRef.current >= 10) unlockAchievement('erotic_fan'); } else eroticStreakRef.current = 0;
            if (sub === "ğŸ¥° å–®ç´”å¯æ„›") { cuteStreakRef.current++; if(cuteStreakRef.current >= 10) unlockAchievement('pure_love'); } else cuteStreakRef.current = 0;
            const d = db[main]?.subs[sub];
            if(d) { setResults(createResultsFromPhrases(getRandomPhrases(d.phrases, settings.resultCount))); setStatus({ type: AppStatusType.SELECTED, text: d.label }); }
            regenCountRef.current = 0;
        };

        const handleRegen = () => {
            if (status.type !== AppStatusType.SELECTED || !currentMain || !currentSub) return;
            triggerHaptic(10);
            const d = db[currentMain]?.subs[currentSub];
            if(d) setResults(createResultsFromPhrases(getRandomPhrases(d.phrases, settings.resultCount)));
            regenCountRef.current++; if (regenCountRef.current >= 20) unlockAchievement('regen_20');
        };

        const handleAiAction = async (type) => {
            if (!inputValue.trim() || (Date.now() - aiLastTime.current < 5000)) { if(inputValue.trim()) { setShakingBtn(type); setTimeout(() => setShakingBtn(null), 500); } return; }
            aiLastTime.current = Date.now(); triggerHaptic(20);
            setStatus({ type: type === 'keyword' ? AppStatusType.GEN_KEYWORD : AppStatusType.GEN_REPLY, text: 'AI ç”Ÿæˆä¸­...' });
            setResults([]);
            window.parent.postMessage({ type: 'REQUEST_BATCH_AI', context: { main: type, sub: inputValue } }, "*"); 
            const phrases = type === 'keyword' ? await generateKeywords(inputValue, settings.resultCount) : await generateReply(inputValue, settings.resultCount);
            setResults(createResultsFromPhrases(phrases));
            setStatus({ type: AppStatusType.IDLE, text: 'AI å®Œæˆ' });
            setCurrentSub(null); unlockAchievement('ai_awakening');
        };

        const handleAiRewrite = async () => {
            if (results.length === 0 || (Date.now() - aiLastTime.current < 5000)) return;
            aiLastTime.current = Date.now(); triggerHaptic(20);
            const context = currentSub ? db[currentMain]?.subs[currentSub]?.label : "è‡ªè¨‚";
            setStatus({ type: AppStatusType.AI_REWRITING, text: 'AI æ”¹å¯«ä¸­...' });
            const rewritten = await rewritePhrases(results.map(r => r.base), context || "");
            setResults(createResultsFromPhrases(rewritten));
            setStatus({ type: AppStatusType.IDLE, text: 'AI æ”¹å¯«å®Œæˆ' });
            unlockAchievement('ai_awakening');
        };

        const handleSearch = () => {
             const q = inputValue.trim().toLowerCase(); if(!q) return;
             unlockAchievement('first_search'); triggerHaptic(10);
             const matches = [];
             Object.values(db).forEach(m => Object.values(m.subs).forEach(s => s.phrases.forEach(p => { if(p.jp.toLowerCase().includes(q) || p.cn.toLowerCase().includes(q)) matches.push(p); })));
             if(matches.length === 0) { setStatus({ type: AppStatusType.IDLE, text: 'ç„¡çµæœ' }); return; }
             setResults(createResultsFromPhrases(getRandomPhrases(matches, settings.resultCount)));
             setCurrentMain(null); setCurrentSub(null); setStatus({ type: AppStatusType.IDLE, text: `æœå°‹: ${inputValue}` });
        };

        const handleCopy = (text) => {
            navigator.clipboard.writeText(text); addXP(1);
            setHistoryLog(p => [text, ...p].slice(0, 20));
            setSettings(p => ({ ...p, totalCopies: p.totalCopies + 1 }));
            unlockAchievement('first_copy');
            if (settings.totalCopies + 1 >= 50) unlockAchievement('copy_50');
            if (Date.now() - copyTimeRef.current < 10000) { copyComboRef.current++; if(copyComboRef.current >= 5) unlockAchievement('combo_master'); } else copyComboRef.current = 1;
            copyTimeRef.current = Date.now(); triggerHaptic(10);
            window.parent.postMessage({ type: 'TRACK_COPY', payload: text }, "*");
        };

        const toggleFavorite = (text) => {
            triggerHaptic(10);
            if (favorites.includes(text)) { setFavorites(p => p.filter(f => f !== text)); unlockAchievement('fav_del'); }
            else { if (favorites.length >= 24) return alert("å·²æ»¿"); setFavorites(p => [...p, text]); addXP(3); unlockAchievement('first_fav'); if(favorites.length+1 >= 24) unlockAchievement('fav_full'); }
        };

        const toggleFeatured = (main, sub, label) => {
            triggerHaptic(10);
            const ex = savedCategories.find(c => c.main === main && c.sub === sub);
            if(ex) setSavedCategories(p => p.filter(c => !(c.main===main && c.sub===sub)));
            else { setSavedCategories(p => [...p, { main, sub, label }]); addXP(3); }
        };

        // Render UI
        const isRegenDisabled = status.type !== AppStatusType.SELECTED;
        const isAiDisabled = results.length === 0 || [AppStatusType.GEN_REPLY, AppStatusType.GEN_KEYWORD, AppStatusType.AI_REWRITING].includes(status.type);

        return (
          <div className="min-h-screen pb-12 px-4 sm:px-6 max-w-3xl mx-auto flex flex-col font-sans relative">
            {activeModal === 'welcome' && <div className="fixed inset-0 z-[60] flex items-center justify-center p-6 bg-black/70 backdrop-blur-md animate-fade-in" onClick={() => setActiveModal(null)}><div className="w-full max-w-sm bg-card dark:bg-card-dark rounded-[40px] overflow-hidden shadow-2xl animate-bounce-small" onClick={e=>e.stopPropagation()}><div className="p-8 pb-10 bg-gradient-to-b from-white to-slate-50 dark:from-zinc-800 dark:to-black text-center relative border-b border-border"><div className="inline-block px-5 py-2 rounded-full bg-gradient-to-r from-primary to-secondary text-white text-xs font-black tracking-widest shadow-lg shadow-primary/30 mb-6 uppercase">âœ¨ ä»Šæ—¥ç´³å£«é‹å‹¢ âœ¨</div><div className="text-7xl mb-6 drop-shadow-xl animate-pulse">{welcomeData.icon}</div><h2 className="text-2xl font-black mb-3 leading-snug text-text">{welcomeData.jp}ï¼</h2><div className="text-sm font-medium text-sub-text bg-bg dark:bg-zinc-800/50 inline-block px-4 py-1 rounded-full">ç´³å£«æŒ‡æ•¸ï¼š<span className="text-yellow-400 drop-shadow-sm ml-1">{"â­".repeat(welcomeData.stars)}</span></div></div><div className="flex bg-bg dark:bg-zinc-900 p-4 gap-3"><button onClick={() => setActiveModal(null)} className="flex-[1.5] py-4 rounded-[20px] bg-primary text-white text-sm font-bold shadow-xl shadow-primary/30 active:scale-95 transition